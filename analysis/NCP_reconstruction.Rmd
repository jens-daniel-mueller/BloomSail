---
title: "NCP reconstruction"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---


```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r packages}
library(tidyverse)
library(ncdf4)
library(seacarb)
library(oce)
library(patchwork)
library(lubridate)
library(metR)
```

```{r ggplot_theme, include = FALSE}
geom_text_size <- (25.4 / 72.27) * 9
theme_set(theme_bw(base_size = 9))
```


```{r read_parameters, include = FALSE}
parameters <-
  read_rds(here::here("data",
                       "parameters.rds"))
```


# Scope of this script

In order to test how well the depth-integrated C~T~* estimates can be reproduced if only surface CO~2~ data were available, the following reconstruction approaches were tested:

- Mixed layer depth: Integration of surface observation across the MLD, assuming homogeneous vertical patterns
- C~T~ profile reconstruction: Vertical reconstruction of incremental C~T~ changes based on profiles of incremental changes in temperature
- Temperature penetration depth:  Integration of surface observation across the temperature penetration depth, assuming similar vertical extension as for C~T~ drawdown.

Note: The reconstruction of C~T~* profiles and the integration across the temperature penetration depth should produce very similar results. However, the latter avoids to create misinterpretable information about the vertical distribution of C~T~*.

The integration depth parameterizations were tested on two data sets, namely:

- BloomSail observations, restricted to C~T~* data in surface water
- SOOP Finnmaid pCO~2~ + vertical hydrographical data from GETM model


```{r subsetting criteria}

date_CT_min <- ymd_hms("2018-07-24 07:58:29")
date_tem_max <- ymd_hms("2018-08-04 00:00:00")

```


# BloomSail

1m gridded, downcast profiles were used.

Mean CO~2~ data from upper `r parameters$surface_dep` meters were used as surface values.


```{r read_prepare_tm}

# read data
tm_profiles_ID <-
  read_csv(
    here::here(
      "data/intermediate/_merged_data_files/NCP_best_guess",
      "tm_profiles_ID.csv"
    )
  )

tm_profiles_ID <- tm_profiles_ID %>% 
  select(-c(date_ID))

# calculate cumulative changes

tm_profiles_ID_long <- tm_profiles_ID %>%
  select(-c(pCO2, sal)) %>% 
  pivot_longer(c("tem", "CT_star"), values_to = "value", names_to = "var") %>% 
  group_by(var, dep) %>%
  arrange(date_time_ID) %>%
  mutate(date_time_ID_diff = as.numeric(date_time_ID - lag(date_time_ID)),
         value_diff = value     - lag(value, default = first(value)),
         value_diff_daily = value_diff / date_time_ID_diff,
         value_cum = cumsum(value_diff)) %>% 
  ungroup()


```

## TPD and CPD

Temperature penetration depth (TPD) and C~T~* penetration depth (CPD) were investigated based on the BloomSail data.

### Cumulative profile July 9

```{r calculate_TPD_cumulative_tm}

# subset date for cumulative assesment
tm_profiles_ID_long_day <- tm_profiles_ID_long %>%
  filter(ID == 180709)

# calculate integrated value of pos/neg changes for Temp/CT*
# and relative contribution with increasing water depth 
tm_profiles_ID_long_day_dep <- tm_profiles_ID_long_day %>%
  select(var, dep, value_cum) %>%
  mutate(
    value_cum = if_else(value_cum > 0 & var == "CT_star",
                        NaN, value_cum),
    value_cum = if_else(value_cum < 0 & var == "tem",
                        NaN, value_cum)
  ) %>%
  group_by(var) %>%
  arrange(dep) %>%
  mutate(
    value_cum_i = sum(value_cum, na.rm = TRUE),
    value_cum_dep = cumsum(value_cum),
    value_cum_i_rel = value_cum_dep / value_cum_i * 100
  ) %>%
  ungroup()

# cumulative integrated values
value_cum <- tm_profiles_ID_long_day_dep %>%
  group_by(var) %>%
  summarise(value_cum_i = mean(value_cum_i)) %>%
  ungroup()

# cumulative surface values
value_surface <- tm_profiles_ID_long_day %>%
  select(var, dep, value_cum) %>%
  filter(dep < parameters$surface_dep) %>%
  group_by(var) %>%
  summarise(value_surface = mean(value_cum)) %>%
  ungroup()

# calculate penentration depth for T and C
PD <- full_join(value_cum, value_surface)
PD <- PD %>%
  mutate(PD = value_cum_i / value_surface)

rm(value_cum, value_surface)


```


```{r PD_cumulative_tm_profiles, fig.asp=1}

p_tm_profiles_ID_long <- tm_profiles_ID_long_day %>%
  arrange(dep) %>%
  ggplot(aes(value_cum, dep)) +
  geom_hline(aes(yintercept = parameters$i_dep_lim, col = "integration")) +
  geom_hline(data = PD, aes(yintercept = PD, col = "penetration")) +
  geom_vline(xintercept = 0) +
  geom_point() +
  geom_path() +
  scale_y_reverse() +
  scale_color_brewer(palette = "Dark2", guide = FALSE) +
  labs(y = "Depth (m)", x = "Cumulative change") +
  theme(legend.position = "left") +
  facet_wrap(var ~ ., ncol = 1, scales = "free_x")

p_tm_profiles_ID_long_rel <- tm_profiles_ID_long_day_dep %>%
  ggplot(aes(value_cum_i_rel, dep)) +
  geom_hline(aes(yintercept = parameters$i_dep_lim, col = "integration")) +
  geom_hline(data = PD, aes(yintercept = PD, col = "penetration")) +
  geom_vline(xintercept = 90) +
  geom_point() +
  geom_line() +
  scale_y_reverse(limits = c(25, 0)) +
  scale_color_brewer(palette = "Dark2", name = "Depth") +
  scale_x_continuous(limits = c(0, NA)) +
  labs(x = "Relative contribution (%)") +
  facet_wrap(var ~ ., ncol = 1, scales = "free_x") +
  theme(axis.title.y = element_blank())

p_tm_profiles_ID_long + p_tm_profiles_ID_long_rel

PD

rm(tm_profiles_ID_long_day_dep,
   p_tm_profiles_ID_long,
   p_tm_profiles_ID_long_rel)

```

### Incremental profile July 9

```{r PD_CPD_cumulative_tm_profiles_example}

col_value <- "red"

p_CT_star <-
  tm_profiles_ID_long_day %>%
  filter(var == "CT_star") %>%
  arrange(dep) %>%
  ggplot() +
  geom_col(
    data = tm_profiles_ID_long_day %>%
      filter(var == "CT_star", value_diff_daily < 0),
    aes(x = value_diff_daily, y = dep),
    width = 1,
    alpha = 0.2,
    orientation = "y"
  ) +
  geom_vline(xintercept = 0) +
  scale_y_reverse(expand = c(0, 0)) +
  annotate(
    "text",
    x = -6,
    y = 11,
    label = "CPD",
    col = col_value,
    size = geom_text_size
  ) +
  annotate(
    "text",
    x = -3.5,
    y = 2.5,
    label = "Integrated\nchange",
    size = geom_text_size
  ) +
  geom_point(aes(value_diff_daily, dep)) +
  geom_path(aes(value_diff_daily, dep)) +
  geom_hline(data = PD %>% filter(var == "CT_star"),
             aes(yintercept = PD),
             col = col_value) +
  labs(y = "Depth (m)", x = expression(paste(Delta ~ C[T], "*") ~ (µmol ~ kg ^ {
    -1
  }))) +
  theme(
    legend.title = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )

p_tem <-
  tm_profiles_ID_long_day %>%
  filter(var == "tem") %>%
  arrange(dep) %>%
  ggplot() +
  geom_col(
    data = tm_profiles_ID_long_day %>%
      filter(var == "tem", value_diff_daily > 0),
    aes(x = value_diff_daily, y = dep),
    width = 1,
    alpha = 0.2,
    orientation = "y"
  ) +
  geom_vline(xintercept = 0) +
  scale_y_reverse(expand = c(0, 0)) +
  annotate(
    "text",
    x = 0.4,
    y = 11,
    label = "PD",
    col = col_value,
    size = geom_text_size
  ) +
  annotate(
    "text",
    x = 0.2,
    y = 2.5,
    label = "Integrated\nchange",
    size = geom_text_size
  ) +
  geom_point(aes(value_diff_daily, dep)) +
  geom_path(aes(value_diff_daily, dep)) +
  geom_hline(data = PD %>% filter(var == "tem"),
             aes(yintercept = PD),
             col = col_value) +
  labs(y = "Depth (m)", x = expression(Delta ~ Temperature ~ (degree * C))) +
  theme(legend.title = element_blank())

p_tem + p_CT_star +
  plot_layout(guides = 'collect') +
  plot_annotation(tag_levels = 'a')

ggsave(
  here::here("output/Plots/Figures_publication/appendix",
             "Fig_C4.pdf"),
  width = 120,
  height = 110,
  dpi = 300,
  units = "mm"
)

ggsave(
  here::here("output/Plots/Figures_publication/appendix",
             "Fig_C4.png"),
  width = 120,
  height = 110,
  dpi = 300,
  units = "mm"
)

rm(PD, tm_profiles_ID_long_day, p_tem, p_CT_star, col_value)

```


### Incremental time series

A time series of TPD and CPD was calculated, based on the incremental (ie from cruise day to cruise day) changes of temperature / C~T~*, taking only pos. / neg. changes of both parameters into account.

```{r calculate_TPD_daily_tm}

# surface values
diff_surface <- tm_profiles_ID_long %>%
  filter(dep < parameters$surface_dep) %>%
  group_by(ID, var) %>%
  summarise(value_diff_surface = mean(value_diff, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(
    value_diff_surface = if_else(value_diff_surface > 0 & var == "CT_star",
                                 NaN, value_diff_surface),
    value_diff_surface = if_else(value_diff_surface < 0 &
                                   var == "tem",
                                 NaN, value_diff_surface)
  )

tm_profiles_ID_long <- full_join(tm_profiles_ID_long, diff_surface)
rm(diff_surface)

# calculate penetration depths for T and C
PD <- tm_profiles_ID_long %>%
  mutate(
    value_diff = if_else(value_diff > 0 & var == "CT_star",
                         NaN, value_diff),
    value_diff = if_else(value_diff < 0 & var == "tem",
                         NaN, value_diff)
  ) %>%
  group_by(var, ID, date_time_ID) %>%
  summarise(
    value_diff_int = sum(value_diff, na.rm = TRUE),
    value_diff_surface = mean(value_diff_surface, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(i_dep = value_diff_int / value_diff_surface)

# calculate temporal mean
PD_mean <- PD %>%
  group_by(var) %>%
  summarise(i_dep_mean = mean(i_dep, na.rm = TRUE),
            i_dep_sd = sd(i_dep, na.rm = TRUE)) %>%
  ungroup()


```

```{r PD_daily_tm_time_series, fig.asp=1}

p_surface <- PD %>%
  ggplot(aes(date_time_ID, value_diff_surface)) +
  geom_hline(yintercept = 0) +
  geom_line() +
  geom_point() +
  scale_y_reverse(name = "Change surface value") +
  scale_x_datetime(breaks = "week", date_labels = "%d %b") +
  scale_color_brewer(palette = "Set1", direction = -1) +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank()) +
  facet_grid(var ~ ., scales = "free_y")

p_integrated <- PD %>%
  ggplot(aes(date_time_ID, value_diff_int)) +
  geom_hline(yintercept = 0) +
  geom_line() +
  geom_point() +
  scale_y_reverse(name = "Change integrated value") +
  scale_x_datetime(breaks = "week", date_labels = "%d %b") +
  scale_color_brewer(palette = "Set1", direction = -1) +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank()) +
  facet_grid(var ~ ., scales = "free_y")

p_pen_dep <- PD %>%
  ggplot(aes(date_time_ID, i_dep, col = var)) +
  geom_hline(yintercept = 0) +
  geom_hline(data = PD_mean,
             aes(
               yintercept = i_dep_mean,
               col = var,
               linetype = "mean"
             )) +
  geom_line(aes(linetype = "cruise")) +
  geom_point() +
  scale_y_reverse(name = "Penetration depth (m)", breaks = seq(0, 20, 5)) +
  scale_x_datetime(breaks = "week", date_labels = "%d %b") +
  scale_color_brewer(palette = "Set1", direction = -1) +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank())


p_surface + p_integrated + p_pen_dep +
  plot_layout(ncol = 1)

PD_mean

rm(p_surface, p_integrated, p_pen_dep)
rm(PD, PD_mean, tm_profiles_ID_long)

```


# GETM model

## Read netcdf file

```{r read_gt_3d_sal_tem_age}

# read netcdf file
nc <- 
  nc_open(here::here("data/input/GETM", "Finnmaid.E.3d.2018.nc"))

# extract latitude vector
lat <- ncvar_get(nc, "latc")

# extract start time
time_start <- nc$dim$time$units %>%
  substr(start = 15, stop = 33) %>%
  ymd_hms()

# create time vecotr
t <- time_start + ncvar_get(nc, "time")
rm(time_start)

# extract depths vector
d <- ncvar_get(nc, "zax")

# read model data
for (var_3d in c("salt", "temp")) {
  
  # store the data in a 3-dimensional array
  array <-
    ncvar_get(nc, var_3d) 
  
  # find NA value
  fillvalue <- ncatt_get(nc, var_3d, "_FillValue")
  
  # replace NA value with NA
  array[array == fillvalue$value] <- NA
  
  for (i in seq(1, length(t), 1)) {
    # i <- 3
    array_slice <- array[, , i] # slices data from one day
    
    # convert to tibble
    array_slice_df <- as.data.frame(t(array_slice))
    array_slice_df <- as_tibble(array_slice_df)
    
    # rename, format and subset data
    gt_3d_part <- array_slice_df %>%
      set_names(as.character(lat)) %>%
      mutate(dep = -d) %>%
      gather("lat", "value", 1:length(lat)) %>%
      mutate(lat = as.numeric(lat)) %>%
      filter(
        lat > parameters$getm_low_lat,
        lat < parameters$getm_high_lat,
        dep <= parameters$max_dep
      ) %>%
      mutate(var = var_3d,
             date_time = t[i]) %>%
      select(date_time, dep, value, var)
    
    
    if (exists("gt_3d")) {
      gt_3d <- bind_rows(gt_3d, gt_3d_part)
    } else {
      gt_3d <- gt_3d_part
    }
    
    rm(array_slice, array_slice_df, gt_3d_part)
    
  }
  rm(array, fillvalue)
  
}

nc_close(nc)
rm(nc)

# subset time period
# calculate daily, regional mean profile in study area
gt_3d_long <- gt_3d %>%
  filter(date_time >= parameters$getm_start_date &
           date_time <= parameters$getm_end_date) %>%
  group_by(date_time, var, dep) %>%
  summarise_all(list(value =  ~ mean(., na.rm = TRUE))) %>% # regional averaging
  ungroup()

gt_3d <- gt_3d_long %>%
  pivot_wider(values_from = value, names_from = var) %>%
  rename(sal = salt, tem = temp)


rm(i, lat, d, t, var_3d)

```

## Sal and tem profiles

```{r gt_profiles_sal_tem}

gt_3d_long %>%
  ggplot(aes(value, dep,
             col = date_time,
             group = date_time)) +
  geom_path() +
  scale_y_reverse(expand = c(0, 0)) +
  scale_color_viridis_c(name = "Date", trans = "time") +
  facet_wrap( ~ var, scales = "free_x", ncol = 2)

rm(gt_3d_long)

```

## Comparison BloomSail

Vertical, 1m-gridded BloomSail CTD profiles were used for comparison with GETM results. Note that the sampling location does not match exactly.

### Interpolate GETM to BloomSail

GETM results were linearly interpolated to the BloomSail depth levels and the mean cruise dates.


```{r interpolate_gt_3d_dep_grid}

gt_3d_int <- gt_3d %>%
  mutate(dep_int = dep + 0.5) %>%
  group_by(date_time) %>%
  mutate(sal_int = approxfun(dep, sal)(dep_int),
         tem_int = approxfun(dep, tem)(dep_int)) %>%
  ungroup() %>%
  select(date_time,
         dep = dep_int,
         sal = sal_int,
         tem = tem_int) %>%
  drop_na()

rm(gt_3d)

```

```{r merge_gt_ts_profiles}

# join GETM and BloomSail profiles
tm_gt_3d <- full_join(
  gt_3d_int,
  tm_profiles_ID %>% select(date_time = date_time_ID,
                            dep, sal, tem),
  by = c("date_time", "dep"),
  suffix = c("_gt", "_tm")
)

# calculate density profiles
tm_gt_3d <- tm_gt_3d  %>%
  mutate(
    rho_gt = swSigma(
      salinity = sal_gt,
      temperature = tem_gt,
      pressure = dep / 10
    ),
    rho_tm = swSigma(
      salinity = sal_tm,
      temperature = tem_tm,
      pressure = dep / 10
    )
  )

# interpolate to BloomSail time stamp
tm_gt_3d <- tm_gt_3d %>%
  arrange(date_time) %>%
  group_by(dep) %>%
  mutate(
    tem_gt = approxfun(date_time, tem_gt)(date_time),
    sal_gt = approxfun(date_time, sal_gt)(date_time),
    rho_gt = approxfun(date_time, rho_gt)(date_time)
  ) %>%
  ungroup() %>%
  drop_na()

```

### S, T, rho profiles

```{r gt_ts_profiles_salt_temp_rho, fig.asp=0.8, fig.cap="STD profiles modeled with GETM (upper panels, gt) and measured during BloomSail campaign (lower panels, ts)"}

# convert to long format
tm_gt_3d_long <- tm_gt_3d %>%
  pivot_longer(
    sal_gt:rho_tm,
    values_to = "value",
    names_to = c("var", "source"),
    names_sep = "_"
  )

tm_gt_3d_long %>%
  ggplot(aes(value, dep,
             col = date_time,
             group = date_time)) +
  geom_path() +
  scale_y_reverse(expand = c(0, 0), name = "Depth (m)") +
  scale_color_viridis_c(name = "Date", trans = "time") +
  facet_grid(source ~ var, scales = "free_x")

```

### S, T, rho offset profiles

```{r gt_ts_profiles_diff_salt_temp_rho, fig.asp=0.5, fig.cap="Offset STD profiles comparing modeled with GETM (upper panels, gt) and measured during BloomSail campaign (lower panels, ts)"}

tm_gt_3d <- tm_gt_3d_long %>%
  pivot_wider(values_from = "value", names_from = "source") %>%
  mutate(value_diff = gt - tm)

tm_gt_3d %>%
  ggplot(aes(value_diff, dep,
             col = date_time,
             group = date_time)) +
  geom_vline(xintercept = 0, col = "red") +
  geom_path() +
  scale_y_reverse(expand = c(0, 0), name = "Depth (m)") +
  scale_color_viridis_c(name = "Date", trans = "time") +
  facet_grid(. ~ var, scales = "free_x") +
  labs(x = "Difference GETM (gt) - Bloomsail (ts)")

rm(tm_gt_3d, tm_gt_3d_long)

```


# SOOP Finnmaid

## Data preparation

```{r read_Finnmaid}

fm <-
 read_csv(here::here("data/intermediate/_summarized_data_files",
                      "fm_bloomsail.csv"))

fm <- fm %>% 
  filter(date_time > parameters$getm_start_date,
         date_time < parameters$getm_end_date) %>% 
  select(ID, date_time, sensor, sal, tem, pCO2) %>% 
  mutate(ID = as.factor(ID))

```

### C~T~* calculation

Calculate C~T~* based on fixed A~T~ and salinity mean values. 

```{r CT_calculation}

# read mean bottle data
fixed_values <- 
  read_csv(here::here("data/intermediate/_summarized_data_files", "tb_fix.csv"))

# calculate CT*
fm <- fm %>%
  mutate(
    CT_star = carb(
      24,
      var1 = pCO2,
      var2 = fixed_values$AT * 1e-6,
      S = fixed_values$sal,
      T = tem,
      k1k2 = "m10",
      kf = "dg",
      ks = "d",
      gas = "insitu"
    )[, 16] * 1e6
  )

```

### Regional averaging

Calculate regional mean and sd values for each crossing of the area.

```{r timeseries_of_regional_averages}

fm_ID <- fm %>%
  pivot_longer(c(pCO2, sal, tem, CT_star),
               values_to = "value",
               names_to = "var") %>%
  group_by(ID) %>%
  mutate(date_time_ID = mean(date_time)) %>%
  ungroup() %>%
  select(-date_time) %>%
  group_by(ID, date_time_ID, sensor, var) %>%
  summarise_all(list( ~ mean(.), ~ sd(.)), na.rm = TRUE) %>%
  ungroup() %>%
  rename(value = mean)

```

### Read tm profile data

Read original profile data and calculate surface mean and sd values.

```{r tm_long_surface}

tm_profiles <-
  read_csv(
    here::here(
      "data/intermediate/_merged_data_files/NCP_best_guess",
      "tm_profiles.csv"
    )
  )

# surface mean calculation
tm_profiles_ID_long_surface <- tm_profiles %>%
  filter(dep < parameters$surface_dep) %>%
  select(-c(dep, date_ID, station, date_time, lat, lon, pCO2_corr)) %>%
  mutate(ID = as.factor(ID)) %>%
  pivot_longer(sal:CT_star, values_to = "value", names_to = "var") %>%
  group_by(ID, date_time_ID, var) %>%
  summarise_all(list( ~ mean(.), ~ sd(.)), na.rm = TRUE) %>%
  ungroup()


```

### Timeseries

```{r fm_tm_time_series, fig.asp=1.2}

fm_ID %>%
  ggplot() +
  geom_rect(data = fixed_values,
            aes(
              xmin = start,
              xmax = end,
              ymin = -Inf,
              ymax = Inf
            ),
            alpha = 0.2) +
  geom_path(aes(x = date_time_ID, y = value)) +
  geom_ribbon(aes(
    x = date_time_ID,
    y = value,
    ymax = value + sd,
    ymin = value - sd,
    fill = "Finnmaid"
  ),
  alpha = 0.3) +
  geom_ribbon(
    data = tm_profiles_ID_long_surface,
    aes(
      x = date_time_ID,
      ymin = mean - sd,
      ymax = mean + sd,
      fill = "BloomSail"
    ),
    alpha = 0.3
  ) +
  geom_point(aes(x = date_time_ID, y = value, col = sensor)) +
  geom_point(data = tm_profiles_ID_long_surface,
             aes(x = date_time_ID, y = mean, col = "BloomSail")) +
  geom_line(data = tm_profiles_ID_long_surface,
            aes(x = date_time_ID, y = mean, col = "BloomSail")) +
  facet_grid(var ~ ., scales = "free_y") +
  scale_color_brewer(palette = "Set1") +
  scale_fill_brewer(palette = "Set1", name = "+/- SD") +
  scale_x_datetime(date_breaks = "week",
                   date_labels = "%b %d") +
  theme(axis.title.x = element_blank())

```

### Missing observations

The observational gaps in the Finnmaid SST and C~T~* time series were filled with:

- two BloomSail observations
- an interpolated Finnmaid value to match the starting date

The time series was restricted to the period where BloomSail observations are available.

```{r fm_interpolate_starting_values}

# create data frame with start dates
tm_start_date <- tm_profiles_ID_long_surface %>% 
  filter(ID %in% c("180705"),
         var %in% c("tem", "CT_star")) %>% 
  select(date_time_ID, ID, var) %>% 
  mutate(sensor = "interpolated")

# add start dates to Finnmaid data
fm_tm_ID <- full_join(fm_ID, tm_start_date) %>% 
  arrange(date_time_ID) %>% 
  filter(var %in% c("tem", "CT_star"))

# interpolate Finnmaid to BloomSail start date
fm_tm_ID <- fm_tm_ID %>% 
  group_by(var) %>% 
  mutate(value = approxfun(date_time_ID, value)(date_time_ID)) %>% 
  ungroup()

rm(tm_start_date)

```


```{r fm_fill_gap_with_tm}

# subset BloomSail data in Finnmaid gap
tm_gap <- tm_profiles_ID_long_surface %>%
  filter(ID %in% c("180718", "180723"),
         var %in% c("tem", "CT_star")) %>%
  select(date_time_ID, ID, var, value = mean) %>%
  mutate(sensor = "BloomSail")

# add data to fill Finnmaid gap
fm_tm_ID <- full_join(fm_tm_ID, tm_gap) %>%
  arrange(date_time_ID) %>%
  select(-sd) %>%
  filter(var %in% c("tem", "CT_star")) %>%
  mutate(
    period = "BloomSail",
    period = if_else(date_time_ID < fixed_values$start, "pre-BloomSail", period),
    period = if_else(date_time_ID > fixed_values$end, "post-BloomSail", period)
  )

# filter only Finnmaid data within BloomSail period
fm_tm_ID <- fm_tm_ID %>%
  filter(period == "BloomSail") %>%
  select(-period)

rm(fm_ID, fm, tm_gap, tm_profiles_ID_long_surface, tm_profiles, fixed_values)

```

### Final time series

```{r fm_time_series_filled}

fm_tm_ID %>%
  ggplot() +
  geom_path(aes(date_time_ID, value)) +
  geom_point(aes(date_time_ID, value, col = sensor)) +
  facet_grid(var ~ ., scales = "free_y") +
  scale_color_brewer(palette = "Set1") +
  scale_x_datetime(date_breaks = "week",
                   date_labels = "%b %d") +
  theme(axis.title.x = element_blank())

```


# Merge all data sets

## Merge fm and gt

```{r fm_gt_merge}

# convert to wide format
fm_tm_ID_wide <- fm_tm_ID %>%
  filter(var %in% c("CT_star")) %>%
  select(date_time_ID, var, sensor, value) %>%
  pivot_wider(values_from = value, names_from = var)

# extend surface data with depth grid
fm_gt <- expand_grid(fm_tm_ID_wide, dep = unique(gt_3d_int$dep))

# join Finnmaid and GETM data
fm_gt <- full_join(fm_gt,
                   gt_3d_int %>% rename(date_time_ID = date_time)) %>%
  arrange(date_time_ID)

rm(fm_tm_ID_wide, fm_tm_ID, gt_3d_int)

```

## Interpolate gt time stamp to fm

GETM data are interpolated to the time of Finnmaid observations.

```{r fm_gt_interpolate_time_stamp}

fm_gt <- fm_gt %>%
  arrange(date_time_ID) %>%
  group_by(dep) %>%
  mutate(
    tem = approxfun(date_time_ID, tem)(date_time_ID),
    sal = approxfun(date_time_ID, sal)(date_time_ID)
  ) %>%
  ungroup() %>%
  arrange(dep) %>%
  filter(!is.na(CT_star))

```

## Bind tm and fm_gt

Here, we merge the in-situ sensor data from SV Tina V with the Finnmaid+GETM data set, in order to perform following computations only once.

```{r tm_fm_gt_bind}

# subset relevant columns and assign source label
tm_profiles_ID <- tm_profiles_ID %>%
  select(-c(ID, pCO2)) %>%
  mutate(source = "tm",
         sensor = "BloomSail")

fm_gt <- fm_gt %>%
  mutate(source = "fm")

# Merge data sets
tm_fm_gt <- bind_rows(tm_profiles_ID, fm_gt)

rm(fm_gt, tm_profiles_ID)

```

## Comparison

### Surface time series

```{r tm_fm_gt_time_series}

# convert to long format
tm_fm_gt_long <- tm_fm_gt %>%
  pivot_longer(sal:CT_star, values_to = "value", names_to = "var")

tm_fm_gt_long %>%
  filter(dep == 3.5) %>%
  ggplot(aes(date_time_ID, value, col = source)) +
  geom_path() +
  geom_point() +
  scale_x_datetime(date_breaks = "week",
                   date_labels = "%b %d") +
  facet_grid(var ~ ., scales = "free_y") +
  labs(title = "Time series at 3.5 m") +
  theme(axis.title.x = element_blank())

```

### Hovmoeller temperature

```{r tm_fm_gt_hovmoeller_tem}

bin <- 2

tm_fm_gt %>%
  ggplot(aes(date_time_ID, dep, z = tem)) +
  geom_contour_fill(breaks = MakeBreaks(bin)) +
  geom_vline(aes(xintercept = date_time_ID),
             col = "white",
             linetype = "1f") +
  scale_fill_viridis_c(
    name = "tem",
    option = "B",
    guide = "colorstrip",
    breaks = MakeBreaks(bin)
  ) +
  scale_y_reverse() +
  scale_x_datetime(date_breaks = "week",
                   date_labels = "%b %d") +
  coord_cartesian(expand = 0) +
  theme(axis.title.x = element_blank()) +
  facet_grid(source ~ .)


rm(bin)
```

# Integration depths

## MLD

### Density calculation

```{r calculate_density}

tm_fm_gt <- tm_fm_gt %>%
  mutate(rho = swSigma(
    salinity = sal,
    temperature = tem,
    pressure = dep / 10
  ))

```


### Hovmoeller density

```{r tm_fm_gt_hovmoeller_rho}

bin <- 0.5

tm_fm_gt %>%
  ggplot() +
  geom_contour_fill(aes(date_time_ID, dep, z = rho),
                    breaks = MakeBreaks(bin)) +
  geom_vline(aes(xintercept = date_time_ID),
             col = "white",
             linetype = "1f") +
  scale_fill_viridis_c(
    name = "rho",
    option = "B",
    guide = "colorstrip",
    breaks = MakeBreaks(bin),
    direction = -1
  ) +
  scale_y_reverse() +
  scale_x_datetime(date_breaks = "week",
                   date_labels = "%b %d") +
  coord_cartesian(expand = 0) +
  theme(axis.title.x = element_blank()) +
  facet_grid(source ~ .)

rm(bin)
```

### MLD calculation

```{r calculate_MLD}

tm_fm_gt_MLD <- expand_grid(tm_fm_gt, rho_lim = parameters$rho_lim_integration_depths)

tm_fm_gt_MLD <- tm_fm_gt_MLD %>%
  arrange(dep) %>%
  group_by(date_time_ID, source, rho_lim) %>%
  mutate(d_rho = rho - first(rho)) %>%
  filter(d_rho > rho_lim) %>%
  summarise(MLD = min(dep)) %>%
  ungroup() %>%
  mutate(rho_lim = as.factor(rho_lim))

```

### Hovmoeller MLD

```{r tm_fm_gt_hovmoeller_tem_MLD}

bin <- 2

tm_fm_gt %>%
  ggplot() +
  geom_contour_fill(aes(date_time_ID, dep, z = tem),
                    breaks = MakeBreaks(bin)) +
  geom_path(data = tm_fm_gt_MLD, aes(date_time_ID, MLD, col = rho_lim)) +
  scale_fill_gradient(
    name = "Tem (°C)",
    guide = "colorstrip",
    breaks = MakeBreaks(bin),
    high = "grey80",
    low = "grey5"
  ) +
  scale_color_viridis_d() +
  scale_y_reverse() +
  scale_x_datetime(date_breaks = "week",
                   date_labels = "%b %d") +
  coord_cartesian(expand = 0) +
  labs(y = "Depth (m)") +
  theme(axis.title.x = element_blank()) +
  facet_grid(source ~ .)


rm(bin)
```

### Select rho criterion

```{r filter_rho_lim}

MLD <- tm_fm_gt_MLD %>%
  filter(rho_lim == parameters$rho_lim) %>%
  select(-rho_lim) %>%
  rename(i_dep = MLD) %>%
  mutate(i_method = "MLD", i_res = "daily")

rm(tm_fm_gt_MLD)

```

### Mean MLD

```{r mean_MLD}

# Filter data before temperature peak, and calculate mean
MLD_mean <- MLD %>%
  filter(date_time_ID <= date_tem_max) %>%
  group_by(source) %>%
  summarise(MLD_mean = mean(i_dep, na.rm = TRUE),
            MLD_sd = sd(i_dep, na.rm = TRUE)) %>%
  ungroup()

MLD_mean

# format mean MLD data frame
MLD_mean <- MLD_mean %>%
  select(-MLD_sd) %>% 
  rename(i_dep = MLD_mean) %>%
  mutate(i_method = "MLD", i_res = "mean")

MLD_dates <- MLD %>%
  select(source, date_time_ID)

MLD_mean <- full_join(MLD_dates, MLD_mean)
MLD <- full_join(MLD, MLD_mean)

rm(MLD_mean)

```


## TPD

### Cumulative changes

```{r calculate_cumulative_changes}

tm_fm_gt_long <- tm_fm_gt %>%
  select(-c(sal)) %>%
  pivot_longer(c("tem", "CT_star"),
               values_to = "value",
               names_to = "var") %>%
  group_by(source, var, dep) %>%
  arrange(date_time_ID) %>%
  mutate(
    date_time_ID_diff = as.numeric(date_time_ID - lag(date_time_ID)),
    value_diff = value - lag(value, default = first(value)),
    value_diff_daily = value_diff / date_time_ID_diff,
    value_cum = cumsum(value_diff)
  ) %>%
  ungroup()

# select only temperature data
tm_fm_gt_long <- tm_fm_gt_long %>%
  filter(var == "tem") %>%
  select(-var)

```

### Temperature profiles

Please note that the cumulative temperature profile of GETM shows a deep maximum below 20m, which must be attributed to water mass exchange rather than surface warming to radiation or heat uptake, which we want to capture here. Therefore, the integration depth of the GETM data was manually restricted to `r parameters$getm_i_dep`m.

```{r cumulative_tem_profile, fig.cap="Profiles of cumulative temperature changes from the GETM model (label fm) and as measured in the field (label tm)."}

tm_fm_gt_long %>%
  filter(date_time_ID == date_CT_min) %>%
  arrange(dep) %>%
  ggplot(aes(value_cum, dep)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = parameters$getm_i_dep) +
  geom_point() +
  geom_path() +
  scale_y_reverse() +
  labs(x = "Cumulative tem change",
       title = as.Date(date_CT_min)) +
  theme(legend.position = "left") +
  facet_grid(. ~ source, scales = "free_x")

```

### Cumulative TPD

```{r calculation_TPD_cumulative}

# subset data at CT* minimum
tm_fm_gt_long_day <- tm_fm_gt_long %>%
  filter(date_time_ID == date_CT_min) %>%
  mutate(
    value_cum = if_else(value_cum < 0,
                        NaN, value_cum),
    value_cum = if_else(source == "fm" &
                          dep > parameters$getm_i_dep,
                        NaN, value_cum)
  )

# integrate cumulative changes
tm_fm_gt_long_day_dep <- tm_fm_gt_long_day %>%
  select(source, dep, value_cum) %>%
  group_by(source) %>%
  arrange(dep) %>%
  mutate(
    value_cum_i = sum(value_cum, na.rm = TRUE),
    value_cum_dep = cumsum(value_cum),
    value_cum_i_rel = value_cum_dep / value_cum_i * 100
  ) %>%
  ungroup()

# extract integrated cumulative value
value_cum <- tm_fm_gt_long_day_dep %>%
  group_by(source) %>%
  summarise(value_cum_i = mean(value_cum_i)) %>%
  ungroup()

# extract surface cumulative value
value_surface <- tm_fm_gt_long_day %>%
  select(source, dep, value_cum) %>%
  filter(dep < parameters$surface_dep) %>%
  group_by(source) %>%
  summarise(value_surface = mean(value_cum)) %>%
  ungroup()

# calculate TPD
TPD <- full_join(value_cum, value_surface)
TPD <- TPD %>%
  mutate(i_dep = value_cum_i / value_surface)

rm(value_cum, value_surface)

```

```{r TPD_cumulative_profiles_180723}

p_tm_fm_gt_long <- tm_fm_gt_long_day %>%
  arrange(dep) %>%
  ggplot(aes(value_cum, dep)) +
  geom_hline(aes(yintercept = parameters$i_dep_lim, col = "fixed\nintegration\ndepth")) +
  geom_hline(data = TPD, aes(yintercept = i_dep, col = "TPD\nestimate")) +
  geom_vline(xintercept = 0) +
  geom_point() +
  geom_path() +
  scale_y_reverse() +
  scale_color_brewer(palette = "Dark2", guide = FALSE) +
  labs(x = "Cumulative change") +
  theme(legend.position = "left") +
  facet_wrap(. ~ source, ncol = 1, scales = "free_x")

p_tm_fm_gt_long_rel <- tm_fm_gt_long_day_dep %>%
  ggplot(aes(value_cum_i_rel, dep)) +
  geom_hline(aes(yintercept = parameters$i_dep_lim, col = "fixed\nintegration\ndepth")) +
  geom_hline(data = TPD, aes(yintercept = i_dep, col = "TPD\nestimate")) +
  geom_vline(xintercept = 90) +
  geom_point() +
  geom_line() +
  scale_y_reverse(limits = c(25, 0)) +
  scale_color_brewer(palette = "Dark2", name = "") +
  scale_x_continuous(limits = c(0, NA)) +
  labs(x = "Relative contribution (%)") +
  facet_wrap(. ~ source, ncol = 1, scales = "free_x") +
  theme(axis.title.y = element_blank())

p_tm_fm_gt_long + p_tm_fm_gt_long_rel

rm(
  tm_fm_gt_long_day,
  tm_fm_gt_long_day_dep,
  p_tm_fm_gt_long,
  p_tm_fm_gt_long_rel
)

TPD_cum <- TPD

rm(TPD)

```


### Incremental TPD

```{r incremental_TPD}

# incremental changes of surface values
diff_surface <- tm_fm_gt_long %>%
  filter(dep < parameters$surface_dep) %>%
  group_by(date_time_ID, source) %>%
  summarise(value_diff_surface = mean(value_diff, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(value_diff_surface = if_else(value_diff_surface < 0,
                                      NaN, value_diff_surface))

tm_fm_gt_long <- full_join(tm_fm_gt_long, diff_surface)
rm(diff_surface)

# calculate penetration depths
TPD <- tm_fm_gt_long %>%
  mutate(
    value_diff = if_else(value_diff < 0,
                         NaN, value_diff),
    value_diff = if_else(source == "fm" & dep > 19,
                         NaN, value_diff)
  ) %>%
  group_by(date_time_ID, source) %>%
  summarise(
    value_diff_int = sum(value_diff, na.rm = TRUE),
    value_diff_surface = mean(value_diff_surface, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(i_dep = value_diff_int / value_diff_surface)

# calculate mean TPD across bloom period
TPD_mean <- TPD %>%
  filter(date_time_ID <= date_CT_min) %>%
  group_by(source) %>%
  summarise(i_dep_sd = sd(i_dep, na.rm = TRUE),
            i_dep = mean(i_dep, na.rm = TRUE)) %>%
  ungroup()

p_surface <- TPD %>%
  ggplot(aes(date_time_ID, value_diff_surface, col = source)) +
  geom_hline(yintercept = 0) +
  geom_line() +
  geom_point() +
  scale_y_reverse(name = "Change surface value") +
  scale_x_datetime(breaks = "week", date_labels = "%d %b") +
  scale_color_brewer(palette = "Set1", direction = -1) +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank())

p_integrated <- TPD %>%
  ggplot(aes(date_time_ID, value_diff_int, col = source)) +
  geom_hline(yintercept = 0) +
  geom_line() +
  geom_point() +
  scale_y_reverse(name = "Change integrated value") +
  scale_x_datetime(breaks = "week", date_labels = "%d %b") +
  scale_color_brewer(palette = "Set1", direction = -1) +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank())

p_TPD <- TPD %>%
  ggplot(aes(date_time_ID, i_dep, col = source)) +
  geom_hline(yintercept = 0) +
  geom_hline(data = TPD_mean,
             aes(
               yintercept = i_dep,
               col = source,
               linetype = "mean"
             )) +
  geom_line(aes(linetype = "cruise")) +
  geom_point() +
  scale_y_reverse(name = "Penetration depth (m)", breaks = seq(0, 20, 5)) +
  scale_x_datetime(breaks = "week", date_labels = "%d %b") +
  scale_color_brewer(palette = "Set1", direction = -1) +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank())


p_surface + p_integrated + p_TPD +
  plot_layout(ncol = 1)

TPD_mean

rm(p_surface, p_integrated, p_TPD)

```

### Join TPD estimates

```{r join_TPD_estimates}

TPD <- TPD %>%
  select(date_time_ID, source, i_dep) %>%
  mutate(i_method = "TPD", i_res = "daily") %>%
  filter(date_time_ID < date_tem_max) %>%
  mutate(i_dep = if_else(is.na(i_dep), 0, i_dep))

TPD_cum <- TPD_cum %>%
  select(source, i_dep) %>%
  mutate(i_method = "TPD", i_res = "cumulative")

TPD_cum <- full_join(MLD_dates, TPD_cum)

TPD_mean <- TPD_mean %>%
  select(source, i_dep) %>%
  mutate(i_method = "TPD", i_res = "mean")

TPD_mean <- full_join(MLD_dates, TPD_mean)

TPD <- full_join(TPD, TPD_cum)
TPD <- full_join(TPD, TPD_mean)

rm(TPD_cum, TPD_mean)

```

## Join TPD and MLD

```{r join_i_dep_estimates}

i_dep <- full_join(MLD, TPD)
rm(MLD, TPD)

```

## Hovmoeller + MLD/TPD

```{r tm_fm_gt_hovmoeller_tem_MLD_TPD, fig.asp=0.5}

bin <- 2

# prepare data sets
i_dep <- i_dep %>%
  mutate(source = factor(source, c("tm", "fm"))) %>%
  mutate(source = fct_recode(
    source,
    `SOOP Finnmaid + GETM model` = "fm",
    `SV Tina V (surface only)` = "tm"
  ))

tm_fm_gt <- tm_fm_gt %>%
  mutate(source = factor(source, c("tm", "fm"))) %>%
  mutate(source = fct_recode(
    source,
    `SOOP Finnmaid + GETM model` = "fm",
    `SV Tina V (surface only)` = "tm"
  ))

p_hov_dep <-
  tm_fm_gt %>%
  ggplot() +
  geom_contour_fill(aes(date_time_ID, dep, z = tem),
                    breaks = MakeBreaks(bin),
                    col = "black",
                    size = 0.1) +
  geom_path(data = i_dep %>% filter(i_res == "daily" & i_dep != 0),
            aes(date_time_ID, i_dep, col = i_method)) +
  scale_fill_gradient(
    name = "Temperature\n(\u00B0C)",
    guide = "colorstrip",
    breaks = MakeBreaks(bin),
    high = "grey90",
    low = "grey20"
  ) +
  guides(fill = guide_colorsteps(barheight = unit(35, "mm"),
                                 barwidth = unit(4, "mm"),
                                 frame.colour = "black",
                                 ticks = TRUE,
                                 ticks.colour = "black")) +
  scale_color_discrete(name = "Reconstruction", guide = FALSE) +
  scale_y_reverse() +
  scale_x_datetime(date_breaks = "week",
                   date_labels = "%b %d",
                   sec.axis = dup_axis()) +
  coord_cartesian(expand = 0) +
  labs(y = expression(atop(Depth, (m)))) +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    strip.background = element_blank(),
    strip.text.x = element_blank(),
    axis.text.x.top = element_blank(),
    plot.margin = margin(0, 0, 0, 0, "cm")
  ) +
  facet_wrap( ~ source)

p_hov_dep

rm(bin)
```

# Surface data + integr. depth

Here, we restrict all C~T~* observations to surface waters, and merge with the integrations depth estimates.

```{r restrict_to_surface_CO2}

# calculate surface water time series
tm_fm_gt_surface <- tm_fm_gt %>%
  filter(dep < parameters$surface_dep) %>%
  select(source, date_time_ID, sensor, CT_star) %>%
  group_by(source, date_time_ID, sensor) %>%
  summarise(CT_star = mean(CT_star, na.rm = TRUE)) %>%
  ungroup()

# calculate incremental and cumulative changes
tm_fm_gt_surface <- tm_fm_gt_surface %>%
  group_by(source) %>%
  arrange(date_time_ID) %>%
  mutate(
    date_time_ID_diff = as.numeric(date_time_ID - lag(date_time_ID)),
    CT_star_diff = CT_star - lag(CT_star, default = first(CT_star)),
    CT_star_cum = cumsum(CT_star_diff)
  ) %>%
  ungroup()


```

```{r merge_obs_i_dep_lim}

iCT <- full_join(tm_fm_gt_surface, i_dep)
rm(tm_fm_gt_surface)

```

# NCP reconstruction

## Integration of C~T~*

Incremental depth-integrated changes of C~T~* are calculated as the product of incremental changes of surface C~T~* and the integration depth parameter.

```{r calculate_iCT}

# integrate incremental CT* changes across depth
iCT <- iCT %>% 
  mutate(CT_i_diff = CT_star_diff * i_dep)

# calculate cumulative changes
iCT <- iCT %>% 
  group_by(source, i_method, i_res) %>%
  arrange(date_time_ID) %>%
  mutate(CT_star_i_cum = cumsum(CT_i_diff/1000)) %>% 
  ungroup()

```

## Read best-guess NCP

```{r read_NCP_best_guess}

tm_NCP_cum <- read_csv(here::here("data/intermediate/_merged_data_files/NCP_best_guess",
                                  "tm_NCP_cum.csv"))

```

## Adapt air sea flux

The air-sea fluxes of CO~2~ previously calculated for the NCP best-guess were also applied to all reconstructed estimates


```{r add_CO2_flux}

# prepare air sea flux data from best-guess approach
tm_NCP_cum_flux <- tm_NCP_cum %>%
  select(date_time, flux_cum)

tm_NCP_cum_flux <-
  expand_grid(
    tm_NCP_cum_flux,
    source = unique(iCT$source),
    i_method = unique(iCT$i_method),
    i_res = unique(iCT$i_res)
  )

NCP_flux <- full_join(iCT %>% rename(date_time = date_time_ID),
                      tm_NCP_cum_flux) %>%
  arrange(date_time)

# linear interpolation of cumulative changes to frequency of the flux estimates estimates
NCP_flux_int <- NCP_flux %>%
  filter(!(i_method == "MLD" & i_res == "cumulative")) %>%
  group_by(source, i_method, i_res) %>%
  mutate(
    CT_star_i_cum = approxfun(date_time, CT_star_i_cum)(date_time),
    flux_cum = approxfun(date_time, flux_cum)(date_time)
  ) %>%
  fill(flux_cum) %>%
  mutate(CT_star_i_flux_cum = CT_star_i_cum + flux_cum) %>%
  ungroup()


```

## Time series

### Without mixing corrrection

Below, we compare all derived NCP reconstructions to the best-guess time series of integrated C~T~* changes, which were only corrected for air-sea fluxes but not for mixing.

```{r NCP_time_series_without_mixing}

iCT <- iCT %>%
  mutate(sensor = if_else(sensor == "BloomSail", sensor, "VOS"))

p_CT_star <- iCT %>%
  ggplot() +
  geom_path(aes(date_time_ID, CT_star)) +
  geom_point(aes(date_time_ID, CT_star, fill = sensor), shape = 21) +
  scale_fill_manual(values = c("white", "black"),
                    guide = FALSE) +
  scale_x_datetime(breaks = "week",
                   date_labels = "%d %b",
                   expand = c(0, 0)) +
  facet_wrap( ~ source) +
  labs(y = expression(atop(paste(C[T], "*"), (mu * mol ~ kg ^ {
    -1
  })))) +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    plot.margin = margin(0, 0, 0, 0, "cm")
  )

p_iCT <- iCT %>%
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_path(data = tm_NCP_cum,
            aes(date_time, CT_star_i_cum),
            col = "black") +
  geom_path(aes(
    date_time_ID,
    CT_star_i_cum,
    col = i_method,
    linetype = i_res
  )) +
  scale_color_discrete(name = "Reconstruction") +
  scale_x_datetime(
    breaks = "week",
    date_labels = "%d %b",
    sec.axis = dup_axis(),
    expand = c(0, 0)
  ) +
  scale_linetype(name = "Resolution") +
  facet_wrap(~ source) +
  labs(y = expression(atop(Integrated ~ nC[T], (mol ~ m ^ {
    -2
  })))) +
  guides(color = guide_legend(order = 1)) +
  theme(
    axis.title.x = element_blank(),
    strip.background = element_blank(),
    strip.text.x = element_blank(),
    axis.text.x.top = element_blank()
  )

p_CT_star / p_hov_dep / p_iCT

```


### With mixing corrrection


Below, we compare four NCP reconstructions based on daily incremental integration depth estimates to the best-guess NCP time series, ie the integrated C~T~* changes, which were corrected for air-sea fluxes and for mixing.

```{r NCP_time_seriess_with_mixing}



NCP_flux <- NCP_flux %>%
  mutate(i_res = factor(i_res, c("mean", "cumulative", "daily")))

p_NCP <- NCP_flux_int %>%
  filter(i_res %in% c("daily")) %>%
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_path(
    data = tm_NCP_cum,
    aes(date_time, CT_star_i_flux_mix_cum, linetype = "best \U2013 guess"),
    col = "black"
  ) +
  geom_path(aes(
    date_time,
    CT_star_i_flux_cum,
    col = i_method,
    linetype = "reconstruction"
  )) +
  scale_color_discrete(name = "Integration depth") +
  scale_x_datetime(
    breaks = "week",
    date_labels = "%d %b",
    sec.axis = dup_axis(),
    expand = c(0, 0)
  ) +
  scale_linetype_manual(name = expression(- NCP~estimate),
                        values = c(2, 1)) +
  facet_wrap(~ source) +
  labs(y = expression(atop(- NCP, (mol ~ m ^ {
    -2
  })))) +
  guides(color = guide_legend(order = 1)) +
  theme(
    axis.title.x = element_blank(),
    strip.background = element_blank(),
    strip.text.x = element_blank(),
    axis.text.x.top = element_blank(),
    plot.margin = margin(0, 0, 0, 0, "cm")
  )

p_CT_star / p_hov_dep / p_NCP +
  plot_annotation(tag_levels = 'a')

ggsave(
  here::here("output/Plots/Figures_publication/article",
             "Fig_6.pdf"),
  width = 160,
  height = 155,
  dpi = 300,
  units = "mm"
)

ggsave(
  here::here("output/Plots/Figures_publication/article",
             "Fig_6.png"),
  width = 160,
  height = 155,
  dpi = 300,
  units = "mm"
)
```

