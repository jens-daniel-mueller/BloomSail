---
title: "Merging and interpolation of observations"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```


```{r packages}
library(tidyverse)
library(lubridate)
library(zoo)
# library(dygraphs)
# library(xts)
```


# CTD and pCO~2~ data

## Merging summarized data sets


```{r load_summarized_data}
# Load Sensor and HydroC data ---------------------------------------------

CTD <- read_csv(here::here("Data/_summarized_data_files",
                              "Tina_V_Sensor_Profiles_Transects.csv"),
                   col_types = list("pCO2" = col_double())) %>% 
  rename(pCO2_analog = pCO2)

HC <- read_csv(here::here("Data/_summarized_data_files", "Tina_V_HydroC.csv"))

# Time offset correction ----------------------------------------------

# Time offset was determined by comparing zeroing reads from Sensor and HC
# in the plots produced in the section Time stamp synchronzity below
# before applying this correction

CTD <- CTD %>% 
  mutate(day = yday(date_time),
         date_time = if_else(day >= 206 & day <= 220,
                             date_time - 80, date_time - 10)) %>% 
  select(-day)

# Merge Sensor and HydroC data --------------------------------------------

df <- full_join(CTD, HC) %>% 
  arrange(date_time)

rm(HC, CTD)
```


## Interpolation to common time stamp

CTD and auxillary recordings (15 sec measurment interval) are interpolated to HydroC time stamps (first 10 sec, than 1 sec measurement interval) when gaps between observations are not larger than 20. Thereafter, HydroC readings not falling in regular transects/profilings are removed, by removing rows with NA depth values. Furthermore, CTD readings without corresponding HydroC reading are removed, except during periods when HydroC was not operating.

```{r interpolation}

# Interpolate Sensor data to HydroC timestamp

df <-
  df %>%
  mutate(dep = na.approx(dep, na.rm = FALSE, maxgap = 20),
         sal = na.approx(sal, na.rm = FALSE, maxgap = 20),
         tem = na.approx(tem, na.rm = FALSE, maxgap = 20),
         pCO2_analog = na.approx(pCO2_analog, na.rm = FALSE, maxgap = 20),
         pH = na.approx(pH, na.rm = FALSE, maxgap = 20),
         V_pH = na.approx(V_pH, na.rm = FALSE, maxgap = 20),
         O2 = na.approx(O2, na.rm = FALSE, maxgap = 20),
         Chl = na.approx(Chl, na.rm = FALSE, maxgap = 20)) %>% 
  filter(!is.na(dep)) %>% #remove HC readings not falling in regular transects/profilings
  fill(ID, type, station, cast) %>% 
  filter(!is.na(deployment) | is.na(pCO2_analog)) # removes CTD readings without corresponding HydroC reading, except during periods when HydroC was not operating

# Time stamp synchronzity -------------------------------------------------
# 
# df <- df %>% 
#   mutate(day = yday(date_time))
# 
# for (dayID in unique(df$day)) {
#   
#   df %>%
#     filter(day == dayID) %>% 
#       ggplot()+
#       geom_point(aes(date_time, pCO2, col="HC"))+
#       geom_point(aes(date_time, dep, col="dep"))+
#       geom_point(aes(date_time, pH, col="pH"))+
#       geom_point(aes(date_time, pCO2_analog, col="Sensor_int"))
#       
#     ggsave(here::here("/Plots/TinaV/Sensor/HydroC_diagnostics/Timing/day",
#                       paste(dayID,"_day_HydroC_merged.jpg", sep="")),
#            width = 10, height = 4)
# }
# 
# 
# for (depID in unique(df$deployment)) {
#   
#   df_dep <- df %>%
#     filter(deployment == depID, Zero == 1)
#   
#   for (zerID in unique(df_dep$Zero_ID)) {
#     
#     df_dep %>%
#       filter(Zero_ID == zerID) %>% 
#       ggplot()+
#       geom_point(aes(date_time, pCO2, col="HC"))+
#       geom_point(aes(date_time, pCO2_analog, col="Sensor_int"))
#     
#     ggsave(here::here("/Plots/TinaV/Sensor/HydroC_diagnostics/Timing/Zeroing",
#                       paste(depID,"_deployment_",zerID,"_Zero_ID_HydroC.jpg", sep="")),
#            width = 10, height = 4)
#     
#   }
# }

```

```{r clean_douplicated_time_stamps}

# add counter for date_time observations

df <- df %>% 
  add_count(date_time)

# find triplicated time stamp and select only first observation, and merge

df_no_triple <- df %>% 
  filter(n <= 2)

df_triple_clean <- df %>% 
  filter(n > 2) %>% 
  slice(1)

df <- full_join(df_no_triple, df_triple_clean)

rm(list=setdiff(ls(), "df"))


# find duplicated time stamps and shift first by one second, and merge

df %>% 
  distinct(date_time)

df_no_duplicated <- df %>%
  filter(n == 1)

df_duplicated <- df %>% 
  filter(n == 2)

df_duplicated_first <- df_duplicated %>% 
  group_by(date_time) %>% 
  slice(1) %>% 
  ungroup() %>% 
  mutate(date_time = date_time - 1)

df_duplicated_second <- df_duplicated %>% 
  group_by(date_time) %>% 
  slice(2) %>% 
  ungroup()

df_duplicated_clean <- full_join(df_duplicated_first, df_duplicated_second) %>% 
  arrange(date_time)

df <- full_join(df_no_duplicated, df_duplicated_clean)

df %>% 
  distinct(date_time)

rm(list=setdiff(ls(), "df"))

# remaining duplicates are observations where other observations with a +/- 1 sec timestamp exist
# for those cases, only the first duplicated observation is selected (similar to triplicate treatment)

df_still_no_duplicated <- df %>% 
  select(-n) %>% 
  add_count(date_time) %>% 
  filter(n == 1)

df_still_duplicated_first <- df %>% 
  select(-n) %>% 
  add_count(date_time) %>% 
  filter(n == 2) %>% 
  group_by(date_time) %>% 
  slice(1)

df <- full_join(df_still_no_duplicated, df_still_duplicated_first)

df %>% 
  distinct(date_time)

rm(list=setdiff(ls(), "df"))

df <- df %>% 
  select(-n)

```


```{r safe_merged_data_file}
write_csv(df, here::here("Data/_merged_data_files", "BloomSail_CTD_HydroC.csv"))
```


```{r merge_back_with_HydroC_raw_data}

HC <-
  read_csv2(here::here("Data/TinaV/Sensor/HydroC-pCO2/corrected_Contros",
                       "parameter&pCO2s(method 43).txt"),
            col_names = c("date_time", "Zero", "Flush", "p_NDIR",
                          "p_in", "T_control", "T_gas", "%rH_gas",
                          "Signal_raw", "Signal_ref", "T_sensor",
                          "pCO2", "Runtime", "nr.ave")) %>% 
  mutate(Flush = as.factor(as.character(Flush)),
         Zero = as.factor(as.character(Zero)))

```



```{r timeseries_pCO2, fig.cap="pCO~2~ record after interpolation to HydroC timestamp (analog output from HydroC and drift corrected data provided by Contos). ID refers to the starting date of each cruise. Please note that pCO~2~ measurement range is restricted to 100-500  µatm here due to the settings of the analog voltage output of the sensor. Zeroing periods are included.", fig.asp = 2.3}

df %>% 
  filter(!is.na(pCO2)) %>% 
  ggplot()+
  geom_path(aes(date_time, pCO2, col = "HydroC, drift corrected"))+
  geom_path(aes(date_time, pCO2_analog, col = "analog CTD"))+
  scale_color_brewer(palette = "Set1", name = "pCO2 record")+
  labs(y=expression(pCO[2]~(µatm)), x="")+
  facet_wrap(~ID, scales = "free_x", ncol = 1)

# ts <- xts(cbind(df$pCO2, df$dep), order.by = df$date_time)
# names(ts) <- c("pCO2", "Depth")
# 
# ts %>% 
#   dygraph() %>% 
#   dyRangeSelector() %>% #dateWindow = c("2012-01-01", "2016-12-31")
#   dySeries("pCO2", label = "pCO2") %>% 
#   dySeries("Depth", axis = 'y2', label = "Depth") %>% 
#   dyAxis("y", label = "pCO2 [µatm]") %>% 
#   dyAxis("y2", label = "Depth [m]") %>% 
#   dyOptions(drawPoints = TRUE, pointSize = 1)

```


# Tasks / open questions

- Check interpolation to CTD Sensor timestamp as alternative option
