---
title: "Merging and interpolation of observations"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: workflowr::wflow_hts_thl
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```


```{r packages}
library(tidyverse)
library(lubridate)
library(zoo)

```


# CTD (ts) + HydroC CO~2~ data (th)

## Merging summarized data sets


```{r load_summarized_data_synchronize_time_stamp, eval=FALSE}

# Load Sensor and HydroC data ---------------------------------------------
ts <- read_csv(here::here("Data/_summarized_data_files",
                          "ts.csv"),
               col_types = list("pCO2_analog" = col_double()))

th <- read_csv(here::here("Data/_summarized_data_files",
                          "th.csv"))

# Time offset correction ----------------------------------------------

# Time offset was determined by comparing zeroing reads from Sensor and th
# in the plots produced in the section Time stamp synchronzity below
# before applying this correction

ts <- ts %>% 
  mutate(day = yday(date_time),
         date_time = if_else(day >= 206 & day <= 220,
                             date_time - 80, date_time - 10)) %>% 
  select(-day)

# Merge Sensor and HydroC data --------------------------------------------

ts_th <- full_join(ts, th) %>% 
  arrange(date_time)

# ts_th_full <- full_join(ts, th_full) %>% 
#   arrange(date_time)

rm(th, ts)
```


## Interpolation to common time stamp

CTD and auxillary recordings (15 sec measurment interval) are interpolated to HydroC time stamps (first 10 sec, than 1 sec measurement interval) when gaps between observations are not larger than 20. Thereafter, HydroC readings not falling in regular transects/profilings are removed, by removing rows with NA depth values. Furthermore, CTD readings without corresponding HydroC reading are removed, except during periods when HydroC was not operating.

```{r interpolation_to_common_timestamp, eval=FALSE}

# Interpolate Sensor data to HydroC timestamp

ts_th <- ts_th %>%
  mutate(dep_maxgap = na.approx(dep, na.rm = FALSE, maxgap = 20),
         dep = approxfun(date_time, dep)(date_time),
         sal = approxfun(date_time, sal)(date_time),
         tem = approxfun(date_time, tem)(date_time),
         pCO2_analog = approxfun(date_time, pCO2_analog)(date_time)) %>% 
  filter(!is.na(dep)) %>% #remove HC readings not falling in regular transects/profilings
  select(- dep_maxgap) %>% 
  fill(ID, type, station) %>% 
  filter(!is.na(deployment) | is.na(pCO2_analog)) # removes CTD readings without corresponding HydroC reading, except during periods when HydroC was not operating

# ts_th_full <-
#   ts_th_full %>%
#   mutate(dep = na.approx(dep, na.rm = FALSE, maxgap = 20),
#          sal = na.approx(sal, na.rm = FALSE, maxgap = 20),
#          tem = na.approx(tem, na.rm = FALSE, maxgap = 20),
#          pCO2_analog = na.approx(pCO2_analog, na.rm = FALSE, maxgap = 20),
#          pH = na.approx(pH, na.rm = FALSE, maxgap = 20),
#          V_pH = na.approx(V_pH, na.rm = FALSE, maxgap = 20),
#          O2 = na.approx(O2, na.rm = FALSE, maxgap = 20),
#          Chl = na.approx(Chl, na.rm = FALSE, maxgap = 20)) %>% 
#   filter(!is.na(dep)) %>% #remove HC readings not falling in regular transects/profilings
#   fill(ID, type, station) %>% 
#   filter(!is.na(deployment) | is.na(pCO2_analog)) # removes CTD readings without corresponding HydroC reading, except during periods when HydroC was not operating

# Time stamp synchronzity -------------------------------------------------
# 
# ts_th <- ts_th %>% 
#   mutate(day = yday(date_time))
# 
# for (dayID in unique(ts_th$day)) {
#   
#   ts_th %>%
#     filter(day == dayID) %>% 
#       ggplot()+
#       geom_point(aes(date_time, pCO2, col="HC"))+
#       geom_point(aes(date_time, dep, col="dep"))+
#       geom_point(aes(date_time, pH, col="pH"))+
#       geom_point(aes(date_time, pCO2_analog, col="Sensor_int"))
#       
#     ggsave(here::here("/Plots/TinaV/Sensor/HydroC_diagnostics/Timing/day",
#                       paste(dayID,"_day_HydroC_merged.jpg", sep="")),
#            width = 10, height = 4)
# }
# 
# 
# for (depID in unique(ts_th$deployment)) {
#   
#   ts_th_dep <- ts_th %>%
#     filter(deployment == depID, Zero == 1)
#   
#   for (zerID in unique(ts_th_dep$Zero_counter)) {
#     
#     ts_th_dep %>%
#       filter(Zero_counter == zerID) %>% 
#       ggplot()+
#       geom_point(aes(date_time, pCO2, col="HC"))+
#       geom_point(aes(date_time, pCO2_analog, col="Sensor_int"))
#     
#     ggsave(here::here("/Plots/TinaV/Sensor/HydroC_diagnostics/Timing/Zeroing",
#                       paste(depID,"_deployment_",zerID,"_Zero_counter_HydroC.jpg", sep="")),
#            width = 10, height = 4)
#     
#   }
# }

```

## Write merged file

```{r safe_merged_data_file, eval=FALSE}

ts_th %>% 
  write_csv(here::here("Data/_merged_data_files/merging_interpolation", "ts_th.csv"))
#write_csv(ts_th_full, here::here("Data/_merged_data_files", "BloomSail_CTD_HydroC_full.csv"))

rm(ts_th)

```

## Time series pCO~2~

### Absolute values

```{r pCO2_time_series, fig.cap="pCO~2~ record after interpolation to HydroC timestamp (analog output from HydroC and drift corrected data provided by Contos). ID refers to the starting date of each cruise. Please note that pCO2_analog measurement range is technically restricted to 100-500  µats_th. Zeroing periods are included.", fig.asp = 3}

ts_th <- read_csv(here::here("data/_merged_data_files/merging_interpolation",
                          "ts_th.csv"),
               col_types = cols(ID = col_character(),
                                pCO2_analog = col_double(),
                                pCO2_corr = col_double(),
                                Zero = col_factor(),
                                Flush = col_factor(),
                                Zero_counter = col_integer(),
                                deployment = col_integer(),
                                duration = col_double(),
                                mixing = col_character()))


ts_th %>% 
  filter(!is.na(pCO2_corr)) %>% 
  ggplot()+
  geom_path(aes(date_time, pCO2_corr, col = "HydroC, drift corrected"))+
  geom_path(aes(date_time, pCO2_analog, col = "analog CTD"))+
  scale_color_brewer(palette = "Set1", name = "pCO2 record")+
  labs(y=expression(pCO[2]~(µats_th)), x="")+
  facet_wrap(~ID, scales = "free_x", ncol = 1)

```

### Offset analog vs post-processed pCO~2~

```{r pCO2_diff_time_series, fig.cap="pCO~2~ difference betweeb HydroC and drift corrected data provided by Contos. Please note that pCO2 range is restricted to +/- 50  µats_th.", fig.asp = 3}

ts_th %>% 
  filter(!is.na(pCO2_corr)) %>% 
  ggplot()+
  geom_path(aes(date_time, pCO2_corr - pCO2_analog))+
  ylim(-30, 0)+
  labs(y=expression(pCO[2]~(µats_th)), x="")+
  facet_wrap(~ID, scales = "free_x", ncol = 1)

```

```{r measurement_frequency, eval=FALSE, include=FALSE}

ts_th <- ts_th %>% 
  mutate(dt = c(0,diff(date_time)))

ts_th %>% 
  filter(dt < 30) %>% 
  ggplot(aes(date_time, dt))+
  geom_point()

```

# Merges sensor (ts_th) + track (tt) data

```{r merge_sensor_track, eval=FALSE}

ts_th <- read_csv(here::here("data/_merged_data_files/merging_interpolation",
                          "ts_th.csv"),
               col_types = cols(ID = col_character(),
                                pCO2_analog = col_double(),
                                pCO2_corr = col_double(),
                                Zero = col_factor(),
                                Flush = col_factor(),
                                Zero_counter = col_integer(),
                                deployment = col_integer(),
                                duration = col_double(),
                                mixing = col_character()))


tt <- read_csv(here::here("Data/_summarized_data_files",
                          "tt.csv"))


tm <- full_join(ts_th, tt) %>% 
  arrange(date_time)

# interpolate tt data and than remove columns that originate from tt time stamp
tm <- tm %>%
  mutate(lat = approxfun(date_time, lat)(date_time),
         lon = approxfun(date_time, lon)(date_time)) %>% 
  filter(!is.na(dep))

tm %>% write_csv(here::here("Data/_merged_data_files/merging_interpolation",
                            "tm.csv"))

rm(tm, ts_th, tt)
```

# Tasks / open questions

